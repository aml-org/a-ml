(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{149:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/example_graph1-5421fb6d7b85bfc3a9b5aeedaf2e0435.png"},150:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/validation_arch-427bc7820053618654a3d94d5311a264.png"},151:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/shacl_diagram-3794d830fa88091d62fc1de6cb1ce23f.png"},75:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return r})),a.d(t,"metadata",(function(){return o})),a.d(t,"toc",(function(){return c})),a.d(t,"default",(function(){return d}));var n=a(3),i=a(7),l=(a(0),a(93)),r={id:"aml_validation_model",title:"AML validation model",hide_title:!0},o={unversionedId:"aml_validation_model",id:"aml_validation_model",isDocsHomePage:!1,title:"AML validation model",description:"AML validation model",source:"@site/../docs/validation_model.mdx",slug:"/aml_validation_model",permalink:"/docs/aml_validation_model",version:"current",lastUpdatedBy:"arielmirra",lastUpdatedAt:1609164773,sidebar:"docs",previous:{title:"AML Specification",permalink:"/docs/aml_spec"},next:{title:"AMF Conversion",permalink:"/docs/related/amf_conversion"}},c=[{value:"Validation approach",id:"validation-approach",children:[{value:"Validation using data shapes",id:"validation-using-data-shapes",children:[]},{value:"Validation Profiles",id:"validation-profiles",children:[]},{value:"Validation architecture",id:"validation-architecture",children:[]}]},{value:"Validation Profile syntax",id:"validation-profile-syntax",children:[{value:"Header and dialect document type",id:"header-and-dialect-document-type",children:[]},{value:"Profile node",id:"profile-node",children:[]},{value:"Identifying classes and properties",id:"identifying-classes-and-properties",children:[]},{value:"ShapeValidation node",id:"shapevalidation-node",children:[]},{value:"PropertyConstraint node",id:"propertyconstraint-node",children:[]},{value:"FunctionValidation node",id:"functionvalidation-node",children:[]},{value:"Modular Validation Profiles: Libraries",id:"modular-validation-profiles-libraries",children:[]},{value:"Modular Validation Profiles: Typed fragments",id:"modular-validation-profiles-typed-fragments",children:[]}]}],b={toc:c};function d(e){var t=e.components,r=Object(i.a)(e,["components"]);return Object(l.b)("wrapper",Object(n.a)({},b,r,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h1",{id:"aml-validation-model"},"AML validation model"),Object(l.b)("h2",{id:"validation-approach"},"Validation approach"),Object(l.b)("p",null,"AMF includes a powerful validation framework that can be used to define constraints and validate them over parsed models for HTTP APIs or any other type of RAML document."),Object(l.b)("p",null,"AMF validation has the following design goals:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Validation is explicit")),Object(l.b)("p",null,"Constraints over the parsed model are explicit. We want to avoid ambiguity about what is valid and invalid for a particular model. All the constraints defined have explicit identifiers and clients can access the full list of validations and their definitions."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"The validation mechanism is formal")),Object(l.b)("p",null,"AMF uses a W3C recommendation ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.w3.org/TR/shacl/"}),"SHACL"),", to implement validation. SHACL provide powerful and clearly defined closed world semantics to validate information models, beyond what can be achieved through more limited validation schema languages like JSON-Schema. Thanks to SHACL sound logical foundation, we can explain easily why a model is invalid."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Validations can be customised")),Object(l.b)("p",null,"AMF introduces the notion of a validation profile. Profiles group validations into sets of related constraints following certain semantics or standard requirements. RAML 1.0,RAML 0.8, OAS 2.0 are valid profiles that will ensure compatibility between the parsed model and these specifications. Furthermore, clients can create a custom validation profile, selecting the validations that are important for their use case, setting the right severity level for each validation or modifying one of the standard profiles, turning on and off individual validations in that profile."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Validations can be extended")),Object(l.b)("p",null,"AMF validation profiles can be extended with custom validations defined by clients. A declarative approach using AMF validation profile dialect can be used to define new validations, or a programmatic mechanism based on JavaScript functions can be followed. Advanced users can always define standard SHACL constraints to have complete control over the validation mechanism."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Validations are data")),Object(l.b)("p",null,"AMF can parse the validation profile for an API and generate a model in the same way it parses the API definition itself. API model and validation profile model can be linked, stored, and queried as a single unified data graph."),Object(l.b)("h3",{id:"validation-using-data-shapes"},"Validation using data shapes"),Object(l.b)("p",null,"The main notion in AMF validation is that of a ",Object(l.b)("inlineCode",{parentName:"p"},"data shape"),"."),Object(l.b)("p",null,"The output of the AMF parser is a data graph where the nodes in the graph, and their relationships capture the information of the input RAML or OAS document."),Object(l.b)("p",null,"Data shapes impose restrictions about the valid properties and relationships for the nodes in the parsed data graph, grouped by node type."),Object(l.b)("p",null,"For example, the following extract from a RAML document located at ",Object(l.b)("inlineCode",{parentName:"p"},"http://exchange.mulesoft.com/myorg/loans.raml"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"\ntitle: Loans API\nversion: 0.3\n\n")),Object(l.b)("p",null,"Will produce the following data graph:"),Object(l.b)("p",null,Object(l.b)("img",{alt:"example1",src:a(149).default})),Object(l.b)("p",null,"As we can see in the image, the 'title' RAML property has been parsed and mapped to the ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"http://schema.org/name"}),"schema-org 'name' property")," in the parsed model, and the 'version' property has been mapped to the ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"http://schema.org/version"}),"schema-org 'version' property"),". At the same time, the main API document located at the root of the document ",Object(l.b)("inlineCode",{parentName:"p"},"#/")," has been marked as being an ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://pending.schema.org/WebAPI"}),"instance of schema-org WebAPI class"),"."),Object(l.b)("p",null,"In order to consider the model encoded in this graph as valid, we might want to impose some restrictions for the nodes in the graph of type ",Object(l.b)("inlineCode",{parentName:"p"},"schema:WebAPI"),", for example, if certain properties are mandatory or optional, the range of the data type for the properties, etc.\nIn order to do this, we can define a 'data shape' constraining all instances of the ",Object(l.b)("inlineCode",{parentName:"p"},"schema:WebAPI")," type. For example, we can make the version mandatory and impose a pattern for the version string. This can be achieved using AMF validation profile syntax in the following way:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{}),'\nvalidations:\n\n  version-constraints:\n    message: Version is mandatory and must be a semantic version M.m.r?\n    targetClass: schema.WebAPI\n    propertyConstraints:\n      schema.version:\n        minCount: 1\n        pattern: "\\d+\\.\\d+(\\.\\d+)?"\n\n')),Object(l.b)("p",null,"This snippet of text declares a new data shape (identified by 'version-constraints') for all instances of the ",Object(l.b)("inlineCode",{parentName:"p"},"schema:WebAPI")," class where for the ",Object(l.b)("inlineCode",{parentName:"p"},"schema.version")," property the minimum count of the property must be 1 (making it mandatory), and the value of the property must match the provided regular expression."),Object(l.b)("p",null,"AMF validation will parse this data shape definition and validate that the model complies with all the data shapes defined. If some constraints are not met, a validation report including the node in the graph that violates the constraint, the identifier of the violated constraint and property, a descriptive message and information about the location in the input document of the model information violating the constraint will be generated."),Object(l.b)("h3",{id:"validation-profiles"},"Validation Profiles"),Object(l.b)("p",null,"In order to use data shapes in any realistic way, a number of data shapes must be defined and re-used together many times to provide a consistency in different RAML documents. We call these sets of related validations 'validation profiles'. AMF allows customers to define validation profiles using a declarative validation syntax."),Object(l.b)("p",null,"Additionally, profiles also support the notion of a severity level for each validation, ranging from ",Object(l.b)("inlineCode",{parentName:"p"},"VIOLATION")," to ",Object(l.b)("inlineCode",{parentName:"p"},"INFO"),", that can be attached to each specific data shape in the profile."),Object(l.b)("p",null,"Profiles can extend other profiles, adding or re-defining validations, changing the severity level or disabling some base profile validations."),Object(l.b)("p",null,"AMF includes by default 3 validation profiles: RAML, OpenAPI and AMF that follow respectively the constraints defined in the RAML 1.0 specification, OpenAPI 2.0 specification and the common set of validations across both specifications."),Object(l.b)("p",null,"For example, the OpenAPI profile defines a validation to make the 'schema:version' property mandatory (identified by amf-parser.mandatory-api-version), but the RAML profile doesn't include this validation since it is not mandatory in RAML."),Object(l.b)("p",null,"AMF clients can decide if they want to use the OpenAPI or RAML standard profile, create a custom profile inheriting from each of these but adapting some data shapes to their own needs or to create a new validation profile completely from scratch."),Object(l.b)("h3",{id:"validation-architecture"},"Validation architecture"),Object(l.b)("p",null,"This section describes the technical details of the AMF validation mechanism. If you are just interested in using the validation mechanism, and you are not interested into advanced use cases like using SHACL directly, this section can be safely skipped."),Object(l.b)("p",null,"The following diagram shows the main components of the validation mechanism in AMF:"),Object(l.b)("p",null,Object(l.b)("img",{alt:"validation arch",src:a(150).default})),Object(l.b)("p",null,"Validation involves two model graphs:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"data graph")),Object(l.b)("p",null,"Generated after parsing the input RAML/OAS document, containing all the information in the domain model, like the HTTP API"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"shapes graph")),Object(l.b)("p",null,"Generated after parsing a custom or standard validation profile and containing restrictions about the shape of the domain entities in the data graph. Shapes are expressed as SHACL shapes."),Object(l.b)("p",null,"The following diagram shows the standard data shapes that can be expressed in SHACL:"),Object(l.b)("p",null,Object(l.b)("img",{alt:"shacl shapes",src:a(151).default})),Object(l.b)("p",null,"Additional shapes can be added to SHACL to define new types of validations. Additionally, SHACL also supports JavaScript constraints that can be defined inline as JavaScript code or collected into validation libraries."),Object(l.b)("p",null,"Both graphs, the data graph and the shapes graph, can be serialised using AMF as ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.w3.org/TR/json-ld/"}),"JSON-LD")," documents containing all the information about the graph."),Object(l.b)("p",null,"In order to trigger the validation, both graphs are passed to the standard SHACL 1.0 library that will compute the potential violations according to SHACL semantics and generate a validation report as an output data graph.\nThis report can be serialised as a JSON-LD document that can be processed by machines or as a human-friendly textual report."),Object(l.b)("h2",{id:"validation-profile-syntax"},"Validation Profile syntax"),Object(l.b)("p",null,"Validation profile documents are defined as a ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/mulesoft/amf/blob/master/vocabularies/dialects/validation.raml"}),"RAML Dialect extension")," (see the documentation about RAML Vocabulary and Dialect to know how to work with RAML extensions)."),Object(l.b)("h3",{id:"header-and-dialect-document-type"},"Header and dialect document type"),Object(l.b)("p",null,"The header identifying the Validation Profile dialect and the current 1.0 version is:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"\n#%Validation Profile 1.0\n\n")),Object(l.b)("p",null,"This header is mandatory in all validation profile documents."),Object(l.b)("h3",{id:"profile-node"},"Profile node"),Object(l.b)("p",null,"The main node in a Validation Profile document is the Profile node."),Object(l.b)("p",null,"These are the possible properties in the node:"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"property"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"description"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"range"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"allow multiple values"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"is map"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"profile"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Name for the custom profile"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"prefixes"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Map of prefixes used to build identifiers in validation of dialects"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"(String,String)"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"true"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"true")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"description?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Human readable description of the profile"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"extends?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Base profile this profile is extending"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string: RAML, OpenAPI, AMF"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"violation?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"List of validations identifiers that will have VIOLATION severity"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"true"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"true")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"warning?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"List of validations identifiers that will have WARNING severity"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"true"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"info?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"List of validations identifiers that will have INFO severity"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"true"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"disabled?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"List of validations from the extended profile that will be disabled"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"true"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"validations?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"List of custom data shapes defining validations in this profile"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ShapeValidation node or FunctionValidation node"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"-"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"true")))),Object(l.b)("p",null,"In order to change the severity level or disable a validation, the identifier of the validation must be added to the right section of the document.\nRefer to the list of standard validations defined for each profile to find which validations can be modified."),Object(l.b)("p",null,"The following example defines a new profile named ",Object(l.b)("inlineCode",{parentName:"p"},"Custom")," extending the RAML standard profile and disabling the ",Object(l.b)("inlineCode",{parentName:"p"},"amf-parser.raml-status-code")," validation including in that profile."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"\n#%Validation Profile 1.0\n\nprofile: Custom\n\nextends: RAML\n\ndisabled:\n  - amf-parser.raml-status-code\n\n")),Object(l.b)("p",null,"Also, note that declaring a validation to the map of ",Object(l.b)("inlineCode",{parentName:"p"},"validations")," does not automatically enable it. Custom validation must still be added to the section with the right severity level for them to be effective."),Object(l.b)("h3",{id:"identifying-classes-and-properties"},"Identifying classes and properties"),Object(l.b)("p",null,"AMF Validation support identifiers for the standard domain elements generated by the AMF parser for RAML and OpenAPI.\nIf you want to other classes and properties, for example when working with dialects, the URI of the element or register a prefix to use CURIEs:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"\n#%Validation Profile 1.0\n\nprofile: Custom Profile for My Vocabulary\n\nprefixes:\n  myvocab: http://myorg.com/vocabularies/myvocab#\n\n")),Object(l.b)("p",null,"Now we could identify target classes and properties using CURIEs like ",Object(l.b)("inlineCode",{parentName:"p"},"myvocab.MyClass")," or ",Object(l.b)("inlineCode",{parentName:"p"},"myvocab.MyProperty"),"."),Object(l.b)("h3",{id:"shapevalidation-node"},"ShapeValidation node"),Object(l.b)("p",null,"Custom data shapes can be defined declaratively as ",Object(l.b)("inlineCode",{parentName:"p"},"ShapeValidation")," nodes that can be added to the ",Object(l.b)("inlineCode",{parentName:"p"},"validations")," property in the profile document."),Object(l.b)("p",null,"These are the properties of a shape validation:"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"property"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"description"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"range"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"allow multiple values"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"is map"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"message?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Error message that will be returned in case of a violation"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"targetClass"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Identifier of the class in the AMF parsed model the data shape will be validating. It must be a valid class identifier in the model"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"propertyConstraints"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"map of property constraints for the data shape"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"PropertyConstraint node"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"-"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"true")))),Object(l.b)("p",null,"Each data shape can contain one or more constraints over properties for the class defined in a property constraint node."),Object(l.b)("p",null,"The following example introduces a shape validation redefining the valid values for the status code of a response:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"\n#%Validation Profile 1.0\n\nprofile: Custom\n\nextends: RAML\n\ndisabled:\n  - amf-parser.raml-status-code\n\nviolation:\n  - my-status-code\n\nvalidations:\n\n  my-status-code:\n    message: Invalid status code value\n    targetClass: http.statusCode\n    propertyConstraint: hydra.statusCode\n    hydra.statusCode:\n      pattern: ^(ok|failure|exception)$\n\n")),Object(l.b)("p",null,"After adding this constraint and disabling the standard RAML status code validation, the following fragment from RAML document will be valid:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"\n/endpoint:\n  get:\n    responses:\n      ok:\n      failure:\n      exception:\n\n")),Object(l.b)("h3",{id:"propertyconstraint-node"},"PropertyConstraint node"),Object(l.b)("p",null,"Each property constraint node is built as a map with keys targeting properties in the AMF parsed model and the constraints for that property in the model."),Object(l.b)("p",null,"The following table defines the constraints that can be used to define the shape of the property in the model:"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"property"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"description"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"range"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"allow multiple values"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"is map"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"pattern?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Regular expression"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"minLength?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Minimum length of a string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"integer"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"maxLength?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Maximum length of a string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"integer"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"maxCount?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Maximum cardinality for the parsed property"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"integer"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"minCount?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Minimum cardinality for the parsed property"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"integer"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"minExclusive?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Minimum exclusive value for the parsed property"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"number"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"maxExclusive?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Maximum exclusive value for the parsed property"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"number"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"minInclusive?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Minimum inclusive value for the parsed property"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"number"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"maxInclusive?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Maximum inclusive value for the parsed property"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"number"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"in?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Enumeration of values allowed for the property"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"any"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"true"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"range?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Literal range of a property from string, integer, float, anyUri, boolean"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}))))),Object(l.b)("p",null,"A single property constraint can have more than one constraint in the map of constraints."),Object(l.b)("h3",{id:"functionvalidation-node"},"FunctionValidation node"),Object(l.b)("p",null,"Alternatively, validations can be defined programmatically using JavaScript functions."),Object(l.b)("p",null,"FunctionConstraint nodes are added to the ",Object(l.b)("inlineCode",{parentName:"p"},"validations")," property by the name of the function constraint and can have the following properties:"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"property"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"description"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"range"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"allow multiple values"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"is map"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"message?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Error message that will be returned in case of a violation"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"targetClass"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Identifier of the class in the AMF parsed model the data shape will be validating. It must be a valid class identifier in the model"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"code?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"JavaScript function that will be invoked to check if a violation has happened for the instance of the target class passed as an argument"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"libraries?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"URLs pointing to JavaScript files including function definitions that will can be used in the validation"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"true"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"functionName?"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Name of a function in one of the libraries that will be used to check if a violation has happened for the instance of the target class passed as an argument"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"string"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"false")))),Object(l.b)("p",null,"Validation functions must be coded as anonymous functions accepting as single input the node in the model encoded as JSON-LD in expanded form  that is an instance of ",Object(l.b)("inlineCode",{parentName:"p"},"targetClass"),".\nValidation functions must return ",Object(l.b)("inlineCode",{parentName:"p"},"true")," if no constraint violation is found or ",Object(l.b)("inlineCode",{parentName:"p"},"false")," to signal a validation error."),Object(l.b)("h4",{id:"js-validation-api"},"JS Validation API"),Object(l.b)("p",null,"AMF validation provides a minimal interface to help build the validation functions:"),Object(l.b)("p",null,"In order to traverse the model, prefixes for all the namespaces in the model have been defined:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-json"}),'\n{\n  "raml-shapes":"http://raml.org/vocabularies/shapes#",\n  "shacl":      "http://www.w3.org/ns/shacl#",\n  "amf-parser": "http://raml.org/vocabularies/amf/parser#",\n  "rdfs":       "http://www.w3.org/2000/01/rdf-schema#",\n  "doc":        "http://raml.org/vocabularies/document#",\n  "data":       "http://raml.org/vocabularies/data#",\n  "owl":        "http://www.w3.org/2002/07/owl#",\n  "meta":       "http://raml.org/vocabularies/meta#",\n  "sourcemaps": "http://raml.org/vocabularies/document-source-maps#",\n  "rdf":        "http://www.w3.org/1999/02/22-rdf-syntax-ns#",\n  "xsd":        "http://www.w3.org/2001/XMLSchema#",\n  "schema":     "http://schema.org/",\n  "http":       "http://raml.org/vocabularies/http#",\n  "sh":         "http://www.w3.org/ns/shacl#",\n  "hydra":      "http://www.w3.org/ns/hydra/core#"\n}\n\n')),Object(l.b)("p",null,"This means that validation code can use ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"http://www.w3.org/TR/curie"}),"CURIEs")," to traverse the model JSON-LD structure instead of full URIs"),Object(l.b)("p",null,"For example the following validation targets the requests in the endpoints. In the validation function to get to the headers, we can just use ",Object(l.b)("inlineCode",{parentName:"p"},"http:header")," instead of the full URI ",Object(l.b)("inlineCode",{parentName:"p"},"http://raml.org/vocabularies/http#header"),":\nNotice that since we are working with the JSON-LD graph in expanded form, the value of a property will always be an array, even if the property has a single value."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"\nvalidations:\n\n  test-validation:\n    message: All requests should have headers\n    targetClass: http.Request\n    functionConstraint:\n      code: |\n        function(request) {\n          var headers = request[http:header];\n          return headers.length > 0;\n        }\n\n")),Object(l.b)("p",null,"Sometimes we need to traverse the model from the root node using a chain of properties. the ",Object(l.b)("inlineCode",{parentName:"p"},"path")," function can be used for this. It accepts a sequence of properties and will try to follow the path returning all the accumulated values found for the path.\nPaths are expressed as sequences of CURIEs joined by the ",Object(l.b)("inlineCode",{parentName:"p"},"/")," separator."),Object(l.b)("p",null,"For example, imagine we need to modify the previous validation to check that a particular header with a name is present in all the requests. In order to do this, we need to traverse from the http:Request to the header (http:header) and from there to the name of each header (schema:header) and check if the name of the property is present. Instead of nesting loops, we could use the ",Object(l.b)("inlineCode",{parentName:"p"},"path")," property for this:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"\nvalidations:\n\n  test-validation:\n    message: Header x-token is mandatory in all requests\n    targetClass: http.Request\n    functionConstraint:\n      code: |\n        function(request) {\n          var pathChain = 'http:header / schema:name';\n          var headerNames = path(request, pathChain);\n          for (var i=0; i<headerNames.length; i++) {\n            if (headerNames[i] === \"x-token\")\n              return true;\n          }\n        }\n\n")),Object(l.b)("p",null,"Validation functions should be stateless, since each validation function is executed independently. However, for certain checks we need to keep state through invocations. In order to accomplish this the validation engine offers a global ",Object(l.b)("inlineCode",{parentName:"p"},"accumulators")," hash persistent between validation function invocations. Validation functions can use this hash to keep state in order to compute certain restrictions."),Object(l.b)("p",null,"For example, let's imagine we need to create a validation checking that the name of the endpoints (resources in RAML, path items in OpenAPI) are unique. For that we can use the ",Object(l.b)("inlineCode",{parentName:"p"},"accumulators")," hash to store the names of the endpoints and find duplicated values:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"\nvalidations:\n\n  unique-identifiers:\n    message: Resource names must be unique\n    targetClass: http.EndPoint\n    functionConstraint:\n      code: |\n        function(resource) {\n          var name = (resource['schema:name'] || [])[0];\n          if(accumulators[name] == null) {\n            accumulators[name] = true;\n            return true;\n          } else {\n            return false;\n          }\n        }\n\n")),Object(l.b)("h3",{id:"modular-validation-profiles-libraries"},"Modular Validation Profiles: Libraries"),Object(l.b)("p",null,"Validation profiles are RAML documents, as such the Validation Profile dialect defines how to split the description into a profile in libraries of data shapes that can be re-used in multiple profiles."),Object(l.b)("p",null,"To declare a validation data shapes library, the following header must be used:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),"\n#%Library / Validation Profile 1.0\n\n")),Object(l.b)("p",null,"In the library validations can be declared using the ",Object(l.b)("inlineCode",{parentName:"p"},"shapes")," for the ShapeValidation nodes and ",Object(l.b)("inlineCode",{parentName:"p"},"functions")," for the FunctionValidation nodes."),Object(l.b)("p",null,"After being declared, validation libraries can be used in a validation profile document using the ",Object(l.b)("inlineCode",{parentName:"p"},"uses")," RAML property and providing an alias for the library\nNotice that a name for the data shape or function constraint connected to the ",Object(l.b)("inlineCode",{parentName:"p"},"validations")," property  will still be required to be able to use the data shape."),Object(l.b)("h3",{id:"modular-validation-profiles-typed-fragments"},"Modular Validation Profiles: Typed fragments"),Object(l.b)("p",null,"In the shame way, data shapes and function constraints can be defined as valid fragments for the Validation Profile dialect and included in a Validation Profile document."),Object(l.b)("p",null,"The required headers for the fragments are the following:"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Fragment header"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Node type"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"#%ShapeValidation / Validation Profile 1.0"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ShapeValidation node")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"#%FunctionValidation / Validation Profile 1.0"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"FunctionValidation node")))))}d.isMDXComponent=!0},93:function(e,t,a){"use strict";a.d(t,"a",(function(){return s})),a.d(t,"b",(function(){return m}));var n=a(0),i=a.n(n);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var b=i.a.createContext({}),d=function(e){var t=i.a.useContext(b),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},s=function(e){var t=d(e.components);return i.a.createElement(b.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},u=i.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,r=e.parentName,b=c(e,["components","mdxType","originalType","parentName"]),s=d(a),u=n,m=s["".concat(r,".").concat(u)]||s[u]||p[u]||l;return a?i.a.createElement(m,o(o({ref:t},b),{},{components:a})):i.a.createElement(m,o({ref:t},b))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,r=new Array(l);r[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:n,r[1]=o;for(var b=2;b<l;b++)r[b]=a[b];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);