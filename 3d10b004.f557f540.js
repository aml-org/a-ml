(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{109:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return u}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),d=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=d(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=d(n),m=a,u=b["".concat(o,".").concat(m)]||b[m]||p[m]||i;return n?r.a.createElement(u,s(s({ref:t},c),{},{components:n})):r.a.createElement(u,s({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},75:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"myStyle",(function(){return c})),n.d(t,"default",(function(){return b}));var a=n(3),r=n(7),i=(n(0),n(109)),o={id:"json_schema_draft_2019_09_to_draft_7",title:"Json Schema Draft 2019-09 to Draft 7 Emission"},s={unversionedId:"related/json_schema_draft_2019_09_to_draft_7",id:"related/json_schema_draft_2019_09_to_draft_7",isDocsHomePage:!1,title:"Json Schema Draft 2019-09 to Draft 7 Emission",description:"This is a technical document, this information is intended for experienced users",source:"@site/../docs/related/json-schema-2019-to-draft-7.mdx",slug:"/related/json_schema_draft_2019_09_to_draft_7",permalink:"/docs/related/json_schema_draft_2019_09_to_draft_7",version:"current",lastUpdatedBy:"arielmirra",lastUpdatedAt:1612286140,sidebar:"docs",previous:{title:"Async + RAML Data Types in AMF",permalink:"/docs/related/async_raml_datatypes"}},l=[{value:"Related aspects",id:"related-aspects",children:[{value:"Error messages",id:"error-messages",children:[]},{value:"Untranslatable keywords",id:"untranslatable-keywords",children:[]}]},{value:"Proposed translations",id:"proposed-translations",children:[]}],c={padding:"15px 5px"},d={toc:l,myStyle:c};function b(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("div",{className:"admonition admonition-info alert alert--info"},Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"Technical Document")),Object(i.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"This is a technical document, this information is intended for experienced users"))),Object(i.b)("h4",{id:"summary"},"Summary"),Object(i.b)("p",null,"This document is an analysis of which parts of Draft 2019-09 can be emitted as Draft 7 to workaround existing lack of validation support for Draft 2019-09.\nThe validators used by AMF have no short-term plans to support this draft."),Object(i.b)("h4",{id:"background"},"Background"),Object(i.b)("p",null,"An initial support of Draft 2019-09 is necessary to start support of OpenAPI 3.1. This support includes parsing, emission and validation.\nThe only aspect that is not owned by AMF is validation, which is delegated to Ajv for the JS Platform and Everit for JVM."),Object(i.b)("p",null,"These libraries won\u2019t be supporting Draft 2019-09 in the short term so we need to workaround this.\nAs we already re-emit parsed Json Schemas to validate them, we want to assess the possibility of cross-emitting Draft 2019-09 to Draft 7 to take advantage of the current supported drafts."),Object(i.b)("h2",{id:"related-aspects"},"Related aspects"),Object(i.b)("h3",{id:"error-messages"},"Error messages"),Object(i.b)("p",null,"Translating Draft 2019-09 into Draft 7 will affect error messages as the schema path in the error will be different from the original. For example:"),Object(i.b)("div",{className:"container"},Object(i.b)("div",{className:"row"},Object(i.b)("div",{style:c,className:"col col--6"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json",metastring:'title="Draft 2019-09"',title:'"Draft','2019-09"':!0}),'{\n  "$schema": "https://json-schema.org/draft/2019-09/schema",\n  "type": "object",\n  "properties": {\n    "name": { "type": "string" },\n    "credit_card": { "type": "number" },\n    "bank_number": { "type": "number"}\n  },\n  "required": ["name"],\n  "dependentSchemas": {\n    "credit_card": {\n      "properties": {\n        "billing_address": { "type": "string" }\n      },\n      "required": ["billing_address"]\n    }\n  },\n  "dependentRequired": {\n    "bank_number": ["credit_card"]\n  }\n}\n'))),Object(i.b)("div",{style:c,className:"col col--6"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json",metastring:'title="Draft 7"',title:'"Draft','7"':!0}),'{\n   "$schema": "https://json-schema.org/draft/draft-07/schema",\n  "type": "object",\n  "properties": {\n    "name": { "type": "string" },\n    "credit_card": { "type": "number" },\n    "bank_number": { "type": "number"}\n  },\n  "required": ["name"],\n  "dependencies": {\n    "credit_card": {\n      "properties": {\n        "billing_address": { "type": "string" }\n      },\n      "required": ["billing_address"]\n    },\n    "bank_number": ["credit_card"]\n  }\n}\n'))))),Object(i.b)("p",null,"These semantically equal schemas are written differently according to the draft version. They both define two dependencies,\none is a subschema and the other is a boolean array. The only difference is the error message they will produce ",Object(i.b)("strong",{parentName:"p"},"if")," the schema path is present."),Object(i.b)("p",null,"On validating the following example, we can see that the ",Object(i.b)("inlineCode",{parentName:"p"},"billing_address")," key is missing:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n  "name": "Someone",\n  "bank_number": 4,\n  "credit_card": 5\n}\n')),Object(i.b)("p",null,"The schema paths of each error are:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Draft 2019-09: ",Object(i.b)("inlineCode",{parentName:"li"},"#/dependentSchemas/credit_card/required")),Object(i.b)("li",{parentName:"ul"},"Draft 7: ",Object(i.b)("inlineCode",{parentName:"li"},"#/dependencies/credit_card/required."))),Object(i.b)("h3",{id:"untranslatable-keywords"},"Untranslatable keywords"),Object(i.b)("p",null,"there are some Draft 2019-09 keywords that cannot be ported to Draft 7 as they are entirely new concepts.\nWe should decide the expected behaviour if a user tries to validate a payload against a Draft 2019-09 parsed schema. There are several options:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Warning or violation when validating")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"We could issue a warning or violation when we detect that a schema parsed from Draft 2019-09 is used.\nTo do this we would have to traverse the schema and detect for specific model attributes. This will add processing time to validation."))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Warning or violation when parsing")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"We could emit a warning or violation when parsing. This is efficient as we only have to detect a Draft 2019-09 specific keyword, something that is necessary for parsing."),Object(i.b)("li",{parentName:"ul"},"The downside is that the \u201cparsing module\u201d fully supports Draft 2019-09, it doesn't make sense to specify a \u201cvalidation rule\u201d on the \u201cparsing module\u201d."))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Only add it to Release Notes")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"The third option is to only add it in the Release Notes and nothing else. Each consumer will be able to handle it as it likes without AMF imposing specific feedback.")))),Object(i.b)("p",null,"All the considered options have to be ",Object(i.b)("strong",{parentName:"p"},"backward compatible"),"."),Object(i.b)("h2",{id:"proposed-translations"},"Proposed translations"),Object(i.b)("h4",{id:"remove-format-keyword-or-turn-off-format-validations-if-possible"},"Remove ",Object(i.b)("inlineCode",{parentName:"h4"},"format")," keyword OR turn off format validations if possible"),Object(i.b)("p",null,"In Draft 2019-09 format validations are turned off. We should respect this in Draft 7 and do one of two:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Remove ",Object(i.b)("inlineCode",{parentName:"li"},"format")," keywords on schema emission to avoid the validation."),Object(i.b)("li",{parentName:"ul"},"Turn off \u201cformat\u201d validations in Ajv and Everit. Ajv seems to be the only one that has it well documented.\nAnother thing to test is how the \u201cformat\u201d value is validated (if it is limited to a possible set of values by the validator)")),Object(i.b)("h4",{id:"change-defs-for-definitions"},"Change ",Object(i.b)("inlineCode",{parentName:"h4"},"$defs")," for ",Object(i.b)("inlineCode",{parentName:"h4"},"definitions")),Object(i.b)("p",null,"A really straight-forward change."),Object(i.b)("h4",{id:"ref-keyword-will-be-emitted-as-allof"},Object(i.b)("inlineCode",{parentName:"h4"},"$ref")," keyword will be emitted as ",Object(i.b)("inlineCode",{parentName:"h4"},"allOf")),Object(i.b)("p",null,"In Json Schema 2019-09 the ",Object(i.b)("inlineCode",{parentName:"p"},"$ref")," keyword can now be alongside other keywords, but we can\u2019t lose the surrounding, same-level information (that is not taken into account when a ",Object(i.b)("inlineCode",{parentName:"p"},"$ref")," is found).\nAccording to several parts in the Json Schema issues, the following transformation should be valid for our use case:"),Object(i.b)("div",{className:"container"},Object(i.b)("div",{className:"row"},Object(i.b)("div",{style:c,className:"col col--6"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json",metastring:'title="Draft 2019-09"',title:'"Draft','2019-09"':!0}),'{\n  "type": "object",\n  "properties": {\n    "name": {\n      "type": "string"\n    }\n  },\n  "$ref": "#/definitions/somewhere"\n}\n'))),Object(i.b)("div",{style:c,className:"col col--6"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json",metastring:'title="Draft 7"',title:'"Draft','7"':!0}),'{\n  "type": "object",\n  "properties": {\n    "name": {\n      "type": "string"\n    }\n  },\n  "allOf": [\n    {\n      "$ref": "#/definitions/somewhere"\n    }\n  ]\n}\n'))))),Object(i.b)("p",null,"If the schema already has an ",Object(i.b)("inlineCode",{parentName:"p"},"allOf"),", the ",Object(i.b)("inlineCode",{parentName:"p"},"$ref")," will simply be appended to it. An annotation will need to be added to signal that it is a top level schema."),Object(i.b)("h4",{id:"unify-dependentschemas-and-dependentrequired-into-dependencies"},"Unify ",Object(i.b)("inlineCode",{parentName:"h4"},"dependentSchemas")," and ",Object(i.b)("inlineCode",{parentName:"h4"},"dependentRequired")," into ",Object(i.b)("inlineCode",{parentName:"h4"},"dependencies")),Object(i.b)("p",null,"These Draft 2019-09 facets should be unified in Draft 7. For example:"),Object(i.b)("div",{className:"container"},Object(i.b)("div",{className:"row"},Object(i.b)("div",{style:c,className:"col col--6"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json",metastring:'title="Draft 2019-09"',title:'"Draft','2019-09"':!0}),'{\n  "$schema": "https://json-schema.org/draft/2019-09/schema",\n  "type": "object",\n  "properties": {\n    "name": { "type": "string" },\n    "credit_card": { "type": "number" },\n    "bank_number": { "type": "number"}\n  },\n  "required": ["name"],\n  "dependentSchemas": {\n    "credit_card": {\n      "properties": {\n        "billing_address": { "type": "string" }\n      },\n      "required": ["billing_address"]\n    }\n  },\n  "dependentRequired": {\n    "bank_number": ["credit_card"]\n  }\n}\n'))),Object(i.b)("div",{style:c,className:"col col--6"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json",metastring:'title="Draft 7"',title:'"Draft','7"':!0}),'{\n  "$schema": "https://json-schema.org/draft/draft-07/schema",\n  "type": "object",\n  "properties": {\n    "name": { "type": "string" },\n    "credit_card": { "type": "number" },\n    "bank_number": { "type": "number"}\n  },\n  "required": ["name"],\n  "dependencies": {\n    "credit_card": {\n      "properties": {\n        "billing_address": { "type": "string" }\n      },\n      "required": ["billing_address"]\n    },\n    "bank_number": ["credit_card"]\n  }\n}\n'))))),Object(i.b)("h4",{id:"unsupported-properties"},"Unsupported properties"),Object(i.b)("p",null,"The following properties will not be translated into Draft 2019-09 as there is no possible construct in Draft 7:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"unevaluatedProperties")," and ",Object(i.b)("inlineCode",{parentName:"li"},"unevaluatedItems")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"minContains")," and ",Object(i.b)("inlineCode",{parentName:"li"},"maxContains")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"contentSchema"))),Object(i.b)("p",null,"Warnings will be added if one of the above fields exist when emitting another Draft that isn\u2019t 2019.\nThe only exception will be ",Object(i.b)("inlineCode",{parentName:"p"},"contentSchema")," that won\u2019t be validated as the spec says it is a SHOULD."))}b.isMDXComponent=!0}}]);